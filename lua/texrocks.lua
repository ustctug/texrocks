-- luacheck: ignore 143
---@diagnostic disable: undefined-field
local lfs    = require "lfs"
local gmatch = string.gmatch

-- FIXME: don't know why luahbtex miss it
-- copied from luatex/source/texk/web2c/luatexdir/lua/luatex-core.lua
if not lfs.mkdirp then
    function lfs.mkdirp(path)
        local full = ""
        local r1, r2, r3
        for sub in gmatch(path, "(/*[^\\/]+)") do
            full = full .. sub
            r1, r2, r3 = lfs.mkdir(full)
        end
        return r1, r2, r3
    end
end

local M = {
    fontmap = string.gsub([[% generated by texrocks

%s

% ex: filetype=texmf
]], '%% ', '%%%% '),
    fontmap_name = "luatex.map"
}

function M.sync(short)
    local dir = ".lux"
    if not lfs.isdir(dir) then
        dir = (os.getenv "XDG_DATA_HOME") .. "/lux/tree"
    end
    if not lfs.isdir(dir) then
        lfs.mkdirp(dir)
    end
    local fontmap_name = dir .. "/" .. M.fontmap_name
    local f = io.open(fontmap_name, 'w')
    if f == nil then
        print("fail to generate " .. fontmap_name)
        return
    end
    local fonts = {}

    local function walk(path)
        for file in lfs.dir(path) do
            if file:sub(1, 1) ~= '.' then
                local newpath = path .. '/' .. file
                if lfs.isdir(newpath) then
                    walk(newpath)
                elseif lfs.isfile(newpath) then
                    local ext = file:gsub(".*%.", "")
                    if ext == "pfb" or ext == "t3" then
                        table.insert(fonts, newpath)
                    end
                end
            end
        end
    end

    for _, path in ipairs(M.getpaths(package.path, "fonts")) do
        walk(path:gsub("//$", ""))
    end
    local lines = {}
    for _, font in ipairs(fonts) do
        local basename = font:gsub(".*/", '')
        local name = basename:gsub("%..*", '')
        local path = font
        if short then
            path = basename
        end
        table.insert(lines, string.format("%s %s <%s", name, name:upper(), path))
    end
    local str = string.format(M.fontmap, table.concat(lines, "\n"))
    f:write(str)
    f:close()
end

function M.getpaths(path, suffix)
    local parts = {}
    local paths = {}
    for part in string.gmatch(path, "([^;]+)") do
        part = part:gsub("/%?.*", "")
        if not parts[part] then
            parts[part] = true
            if suffix == "" then
                table.insert(paths, part)
            else
                part = part:gsub("/src$", ""):gsub("/lib$", "") .. '/etc/' .. suffix
                if lfs.isdir(part) then
                    part = part .. "//"
                    table.insert(paths, part)
                end
            end
        end
    end
    return paths
end

function M.getenv(path, suffix)
    local processed = M.getpaths(path, suffix)
    return table.concat(processed, ";")
end

function M.setenv(key, value)
    if os.getenv(key) == nil then
        os.setenv(key, value)
    end
end

function M.setfontenv(key, value)
    os.setenv(key,
        "$TEXMFDOTDIR;" .. M.getenv(package.path, "fonts/" .. value) .. ";" .. M.OSFONTDIR)
end

if os.type == "windows" then
    M.OSFONTDIR = "C:/Windows/System32/Fonts"
elseif os.type == "unix" then
    if os.getenv "XDG_DATA_DIRS" ~= nil then
        M.OSFONTDIR = "{" .. os.getenv("XDG_DATA_DIRS"):gsub(":", ",") .. "}/share/fonts//"
    else
        local prefixes = { "/usr" }
        if os.getenv "PREFIX" ~= nil then
            prefixes = { os.getenv "PREFIX" }
        elseif os.name ~= "cygwin" then
            table.insert(prefixes, "/usr/local")
        elseif os.getenv "MINGW_PREFIX" ~= nil then
            table.insert(prefixes, os.getenv "MINGW_PREFIX")
        end
        M.OSFONTDIR = "{" .. table.concat(prefixes, ",") .. "}/share/fonts//"
    end
end
if os.name == "macosx" then
    M.OSFONTDIR = M.OSFONTDIR .. ";{/System,}/Library/Fonts//"
elseif os.name == "cygwin" then
    M.OSFONTDIR = M.OSFONTDIR .. ";/proc/cygdrive/c/Windows/System32/Fonts"
end

function M.setenvs()
    M.setenv("TEXMFDOTDIR", ".")
    if os.getenv "USERPROFILE" == nil then
        M.setenv("HOME", "~")
    else
        M.setenv("HOME", os.getenv "USERPROFILE")
    end
    -- https://wiki.archlinux.org/title/XDG_Base_Directory#Partial
    if os.getenv "LOCALAPPDATA" == nil then
        M.setenv("XDG_CONFIG_HOME", (os.getenv "HOME") .. "/.config")
    else
        M.setenv("XDG_CONFIG_HOME", os.getenv "LOCALAPPDATA")
    end
    if os.getenv "APPDATA" == nil then
        M.setenv("XDG_DATA_HOME", (os.getenv "HOME") .. "/.local/share")
    else
        M.setenv("XDG_CONFIG_HOME", os.getenv "APPDATA")
    end
    if os.getenv "TEMP" == nil then
        M.setenv("XDG_CACHE_HOME", (os.getenv "HOME") .. "/.cache")
    else
        M.setenv("XDG_CACHE_HOME", os.getenv "TEMP")
    end
    -- some tex packages like hyperref support config file such as hyperref.cfg
    M.setenv("TEXMFCONFIG", "$XDG_CONFIG_HOME/texmf")
    M.setenv("TEXMFHOME", "$XDG_DATA_HOME/texmf")
    M.setenv("TEXMFVAR", "$XDG_CACHE_HOME/texmf")
    -- project setting > config > data > cache
    -- create ./*.cnf to override
    os.setenv("TEXMF", "$TEXMFDOTDIR;$TEXMFCONFIG;$TEXMFHOME;$TEXMFVAR")
    -- create ./texmf.cnf to override lua/texrocks/texmf.cnf
    os.setenv("TEXMFCNF",
        "$TEXMFDOTDIR;$TEXMFCONFIG;$TEXMFHOME;$TEXMFVAR;" .. debug.getinfo(1).source:match("@?(.*)/") .. '/texrocks')

    os.setenv("LUAINPUTS", "$TEXMFDOTDIR;" .. M.getenv(package.path, ""))
    os.setenv("CLUAINPUTS", "$TEXMFDOTDIR;" .. M.getenv(package.cpath, ""))
    os.setenv("TEXINPUTS", "$TEXMFDOTDIR;" .. M.getenv(package.path, "tex"))

    os.setenv("TEXFONTMAPS", ".lux;$XDG_DATA_HOME/lux/tree")
    os.setenv("TEXFORMATS", "$TEXMFDOTDIR;" .. M.getenv(package.path, "web2c"))
    -- font metrics
    M.setfontenv("TFMFONTS", "tfm")
    M.setfontenv("OFMFONTS", "ofm")
    -- luatex
    M.setfontenv("T1FONTS", "type1")
    M.setfontenv("OVFFONTS", "ovf")
    M.setfontenv("VFFONTS", "vf")
    -- luahbtex
    M.setfontenv("TTFONTS", "truetype")
    M.setfontenv("OPENTYPEFONTS", "opentype")
end

function M.run(args)
    M.setenvs()
    M.sync(false)
    if #args == 0 then
        args = { os.getenv "SHELL" or os.getenv "ComSpec" or "sh" }
    end
    if arg[-1] ~= '--luaonly' then
        local cmd = table.concat(args, ' ')
        os.exec(cmd)
    end
    for i = 0, #arg - 1 do
        arg[i] = arg[i + 1]
    end
    arg[#arg] = nil
    loadfile(arg[0])()
end

function M.main(args)
    local arg0 = args[0]
    arg0 = arg0:gsub(".*[/\\]", "")
    local cmd = "--fmt=%s"
    local cmd_args = { args[-2] }
    if arg0 ~= "texlua" then
        cmd = cmd:format(arg0)
        table.insert(cmd_args, cmd)
    else
        cmd = args[1]
    end
    -- --ini/--fmt/\input conflict with --luaonly
    if cmd:match("^-") == cmd:match("^\\") then
        table.insert(cmd_args, args[-1])
    end
    for _, v in ipairs(args) do
        table.insert(cmd_args, v)
    end

    -- copy self to a new wrapper
    local is_ini = false
    local exe
    for _, opt in ipairs(args) do
        if opt == "--ini" or opt == "-ini" then
            is_ini = true
        elseif opt:match("%.ini$") then
            exe = opt:gsub("%.ini$", "")
        end
    end
    if is_ini and exe ~= nil then
        local f = io.open(exe, "w")
        if f then
            local self = io.open(args[0])
            if self then
                f:write(self:read("*a"))
                self:close()
            end
            f:close()
            if os.type == "unix" then
                os.execute(table.concat({ "chmod", "+x", exe }, ' '))
            else
                -- TODO: support windows
            end
        end
    end
    M.run(cmd_args)
end

function M.preparse(args)
    local cmd_args = {}
    local offset
    local fmt = ''
    for k, v in ipairs(args) do
        if v:sub(1, 6) == '--fmt=' then
            fmt = v:sub(7):gsub('%.fmt', '')
        end
        local char = v:sub(1, 1)
        if offset == nil and char ~= "-" and char ~= "\\" then
            offset = k
        end
        if offset then
            cmd_args[k - offset] = v
        end
    end
    return cmd_args, fmt
end

return M
